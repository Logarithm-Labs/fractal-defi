from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional

import numpy as np
import pandas as pd

from fractal.core.base.entity import GlobalState, InternalState


@dataclass
class StrategyMetrics:
    """
    Default metrics of the strategy.
    """
    accumulated_return: float  # total return of the strategy
    apy: float                 # annualized return
    sharpe: float              # risk-adjusted return
    max_drawdown: float        # maximum drawdown


@dataclass
class StrategyResult:
    """
    Result of the strategy running.
    It contains the timestamps, internal states, global states of all entities
    and total balances

    Methods:
        get_metrics(data: pd.DataFrame) -> StrategyMetrics
        get_default_metrics() -> StrategyMetrics
        to_dataframe() -> pd.DataFrame
    """
    timestamps: List[datetime]
    internal_states: List[Dict[str, InternalState]]
    global_states: List[Dict[str, GlobalState]]
    balances: List[Dict[str, float]]

    def get_metrics(self, data: pd.DataFrame, notional_price: Optional[str | float] = None) -> StrategyMetrics:
        """
        Calculate metrics of the strategy by StrategyResult data.
        StrategyResult data can be generated by to_dataframe() method.

        Args:
            data (pd.DataFrame): DataFrame with the result.
            notional_price (Optional[str | float], optional): Notional price of the asset.
                If it is None, the notional price is 1.
                If it is a string, the notional price is column name of the DataFrame {entity}_{state_name}
                For example, if notional_price='SPOT_price', the notional price is price of global_state of SPOT.
                If it is a float, the notional price is the value of the float.

        Returns:
            StrategyMetrics: Metrics of the strategy.
        """
        data = data.sort_values('timestamp').copy()
        if notional_price is None:
            notional_price = 1
        elif isinstance(notional_price, str):
            notional_price = data[notional_price].values
        elif isinstance(notional_price, float):
            pass
        else:
            raise ValueError("notional_price must be None, str or float")
        data['net_balance'] /= notional_price
        accumulated_return: float = data['net_balance'].iloc[-1] / data['net_balance'].iloc[0] - 1
        total_seconds: float = (data['timestamp'].iloc[-1] - data['timestamp'].iloc[0]).total_seconds()
        total_years: float = total_seconds / (60 * 60 * 24 * 365)
        apy = accumulated_return / total_years
        data_frequency = len(data) / total_years

        net_balance_std = data['net_balance'].pct_change().std()
        if net_balance_std == 0:
            sharpe = 0
        else:
            sharpe = data['net_balance'].pct_change().mean() / net_balance_std
        sharpe *= np.sqrt(data_frequency)  # annualize sharpe

        net_balance = data['net_balance'].values
        cumulative_max = np.maximum.accumulate(net_balance)
        drawdowns = net_balance / cumulative_max - 1
        max_drawdown = np.min(drawdowns)

        return StrategyMetrics(
            accumulated_return=accumulated_return,
            apy=apy,
            sharpe=sharpe,
            max_drawdown=max_drawdown
        )

    def get_default_metrics(self) -> StrategyMetrics:
        """
        Calculate default metrics of the strategy.

        Returns:
            StrategyMetrics: Metrics of the strategy.
        """
        data = self.to_dataframe()
        return self.get_metrics(data)

    def to_dataframe(self) -> pd.DataFrame:
        """
        Convert the result to a DataFrame.
        This version recursively flattens nested attributes in internal_states and global_states.

        Returns:
            pd.DataFrame: DataFrame with the result.
        """
        def flatten(value, parent_key='', sep='_'):
            """
            Recursively flattens an object or list to a dict with compound keys.
            """
            items = {}
            # Base case: simple types
            if isinstance(value, (str, int, float, bool, type(None))):
                items[parent_key] = value
            # If it's a list, flatten each element with an index appended to the key.
            elif isinstance(value, list):
                for i, elem in enumerate(value):
                    new_key = f"{parent_key}{sep}{i}" if parent_key else str(i)
                    items.update(flatten(elem, new_key, sep=sep))
            # If it has a __dict__ (like a dataclass or custom object), flatten its attributes.
            elif hasattr(value, '__dict__'):
                for k, v in value.__dict__.items():
                    new_key = f"{parent_key}{sep}{k}" if parent_key else k
                    items.update(flatten(v, new_key, sep=sep))
            # If it's a dictionary, flatten its items.
            elif isinstance(value, dict):
                for k, v in value.items():
                    new_key = f"{parent_key}{sep}{k}" if parent_key else k
                    items.update(flatten(v, new_key, sep=sep))
            else:
                # Fallback: use the value as-is
                items[parent_key] = value
            return items

        rows = []
        # Iterate through each timestamp and flatten the corresponding state and balance info.
        for i, timestamp in enumerate(self.timestamps):
            row = {'timestamp': timestamp}

            # Flatten each internal state under its entity name.
            for entity_name, internal_state in self.internal_states[i].items():
                flat_internal = flatten(internal_state, parent_key=entity_name)
                row.update(flat_internal)

            # Flatten each global state under its entity name.
            for entity_name, global_state in self.global_states[i].items():
                flat_global = flatten(global_state, parent_key=entity_name)
                row.update(flat_global)

            # Add balances (assumed to be scalars).
            for entity_name, balance in self.balances[i].items():
                row[f"{entity_name}_balance"] = balance

            rows.append(row)

        df = pd.DataFrame(rows)
        # Optionally, calculate a net_balance column by summing all balances.
        balance_cols = [col for col in df.columns if col.endswith('_balance')]
        df['net_balance'] = df[balance_cols].sum(axis=1)
        return df
